package com.example.notify.ui.viewmodel

import android.content.Context
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.notify.NotificationScheduler
import com.example.notify.data.Task
import com.example.notify.data.TaskDao
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.SharingStarted
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.combine
import kotlinx.coroutines.flow.stateIn
import kotlinx.coroutines.launch
import java.util.Calendar

class TaskViewModel(private val taskDao: TaskDao, private val context: Context) : ViewModel() {

    // Flow of all tasks (used by AllTasks screen)
    private val _allTasks: StateFlow<List<Task>> = taskDao.getAllTasks().stateIn(
        viewModelScope,
        SharingStarted.WhileSubscribed(5000),
        emptyList()
    )
    // You might expose allTasks if needed elsewhere, but filteredTasks is used for the list display

    // MutableStateFlow to hold the search query for AllTasks screen
    private val _searchQuery = MutableStateFlow("")
    val searchQuery: StateFlow<String> = _searchQuery.asStateFlow()

    // Combined flow for filtered tasks for AllTasks screen
    val filteredTasks: StateFlow<List<Task>> = combine(_allTasks, _searchQuery) { tasks, query ->
        if (query.isBlank()) {
            tasks
        } else {
            tasks.filter { task ->
                task.title.contains(query, ignoreCase = true)
            }
        }
    }.stateIn(
        viewModelScope,
        SharingStarted.WhileSubscribed(5000),
        emptyList()
    )

    // MutableStateFlow for search query for upcoming tasks (used by HomeScreen)
    private val _upcomingSearchQuery = MutableStateFlow("")
    val upcomingSearchQuery: StateFlow<String> = _upcomingSearchQuery.asStateFlow()

    // Flow of upcoming tasks from the database (used by HomeScreen)
    private val _upcomingTasks: StateFlow<List<Task>> = taskDao.getUpcomingTasks(Calendar.getInstance().timeInMillis).stateIn(
        viewModelScope,
        SharingStarted.WhileSubscribed(5000),
        emptyList()
    )

    // Combined flow for filtered upcoming tasks for HomeScreen
    val filteredUpcomingTasks: StateFlow<List<Task>> = combine(_upcomingTasks, _upcomingSearchQuery) { tasks, query ->
        if (query.isBlank()) {
            tasks
        } else {
            tasks.filter { task ->
                task.title.contains(query, ignoreCase = true)
            }
        }
    }.stateIn(
        viewModelScope,
        SharingStarted.WhileSubscribed(5000),
        emptyList()
    )

    fun insertTask(task: Task) {
        viewModelScope.launch {
            val newRowId = taskDao.insertTask(task)
            // Schedule notification after insertion
            NotificationScheduler.scheduleNotification(
                context,
                task.copy(id = newRowId), // Use the ID generated by the database
                newRowId// Pass the ID as requestCode (assuming it fits in an Int)
            )
        }
    }
    fun getTaskById(taskId: Long): Flow<Task?> {
        return taskDao.getTaskById(taskId) // Delegate to your TaskDao
    }

    fun deleteTask(task: Task) {
        viewModelScope.launch {
            // 1. Cancel the scheduled notification
            NotificationScheduler.cancelNotification(context, task.id) // Assuming id fits in Int for cancellation

            // 2. Delete the task from the database
            taskDao.deleteTask(task)
        }
    }
    fun updateTask(task: Task) {
        viewModelScope.launch {
            NotificationScheduler.cancelNotification(context, task.id.toInt().toLong())
            taskDao.updateTask(task)
            NotificationScheduler.scheduleNotification(context, task, task.id.toInt().toLong())
        }
    }

    fun updateSearchQuery(query: String) {
        _searchQuery.value = query
    }
    fun updateUpcomingSearchQuery(query: String) {
        _upcomingSearchQuery.value = query
    }
}

// TaskViewModelFactory should be in its own file or accessible
// Keep your TaskViewModelFactory here or ensure it's correctly imported
// class TaskViewModelFactory(private val context: Context) : ViewModelProvider.Factory { ... }
